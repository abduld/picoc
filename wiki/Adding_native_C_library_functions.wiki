#summary Adding native C library functions
#labels User-Library-Creation

= Introduction =

picoc allows you to define your own library functions. These functions are written in C using your system's native C compiler. Since the native C compiler can access the hardware this means you can add functions which give picoc control of your hardware.


= How libraries work =

Your picoc distribution will contain a two files which are used to define library functions for your system. If your system is called "foobar" you'll be using:
  * *library_foobar.c* - this is where the foobar-specific library functions go
  * *clibrary.c* - this is where standard C library functions like printf() are defined

We'll start by defining a simple function in *library_foobar.c*. We need to do two things:
  * add the function prototype to our list of picoc library functions
  * define the native C implementation of the function


== The prototype list ==

Each of the *library_XXX.c* files defines a list of picoc prototypes for each of the functions it defines. For example:

{{{
struct LibraryFunction PlatformLibrary[] =
{
    { ShowComplex,  "void ShowComplex(struct complex *)" },
    { Cpeek,        "int peek(int, int)" },
    { Cpoke,        "void poke(int, int, int)" },
    { Crandom,      "int random(int)" },
    { NULL,         NULL }
};
}}}

The first column is the name of the C function. The second column is the function prototype. The "{ NULL, NULL }" line at the end is required.


== The native C function ==

The native C function is called with these parameters:

{{{
void MyCFunc(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs);
}}}

 * *struct ParseState `*`Parser* - this contains internal information about the progress of parsing. It's mostly used here so error messages from your function can report the line number where an error occurred.
 * *struct Value `*`ReturnValue* - this points to the place you can put your return value. This is pre-created as a value of the correct return type so all you have to do is store your result here.
 * *struct Value `**`Param* - this points to an array of parameters. These are all pre-checked as being the correct type.
 * *int NumArgs* - this is the number of parameters. Normally this will already have been checked and will be exactly what you've defined in your function prototype. It is however possible to define functions with variable numbers of arguments using a stdarg-like "..." method and this is where you find out how many parameters were passed in if you're doing that.

Here's an example function definition of "random" (as defined above):
{{{
void Crandom(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)
{
    ReturnValue->Val->Integer = random() % Param[0]->Val->Integer;
}
}}}

This function calls "random()" from the C standard library. It accesses an integer parameter and returns an integer value. 


= Passing parameters =

We've seen how to pass integers into functions. What about passing other data types?

|| *Type*   || *Method*                   || *Comment* ||
|| int      || Param`[`x`]`->Val->Integer ||           ||
|| char     || Param`[`x`]`->Val->Integer || Treated as 'int' here ||
|| double   || Param`[`x`]`->Val->FP      || Only available on some systems ||
|| float    || Param`[`x`]`->Val->FP      || Same as 'double' ||
|| enum     || Param`[`x`]`->Val->Integer || Gives integer value of enum ||
|| pointers || See section below          || Slightly more complicated ||
|| char `*` || See section below          || Slightly more complicated ||
|| arrays   || See section below          || Slightly more complicated ||
|| struct   || See section below          || Slightly more complicated ||
|| union    || See section below          || Slightly more complicated ||


== Passing pointers ==

Pointer parameters are slighty more complicated to access since you have to dereference the pointer to get at the underlying data.

The behind-the-scene definition of pointers in picoc tries to protect the embedded system from programmer errors by making pointers safer. It does this by tracking some more information about what the pointer's pointing to. This makes accessing a pointer a little more complicated but prevents your system from crashing.

Pointers are defined as:
  * a value which the pointer points to, plus
  * an offset into the value if it's an array or a struct and you're not pointing to the first element

For safety we prevent pointers from referring to non-existent memory or from accessing memory outside certain bounds.

Here's how we dereference a pointer parameter. In this example I'll be reading an 'int `*`' parameter:

{{{
    struct Value *IntArray = Param[0]->Val->Pointer.Segment;
    int Offset = Param[0]->Val->Pointer.Offset;
    int IntValue;
    
    if (Offset < 0 || Offset > (IntArray->Val->Array.Size-1) * sizeof(int))
        ProgramFail(Parser, "invalid pointer");
    else
        IntValue = *(int *)(IntArray->Val->Array.Data + Offset);
}}}

Note how I call ProgramFail() here if the pointer is invalid. You can use ProgramFail() for any other errors you encounter as well. ProgramFail() works like printf() - it accepts formatting and a variable number of parameters.


== Passing strings / char `*` ==

In this example I'll be reading a 'char `*`' parameter. It's pretty similar to the 'int `*`' example above:

{{{
    struct Value *CharArray = Param[0]->Val->Pointer.Segment;
    int Offset = Param[0]->Val->Pointer.Offset;
    char *CharPtr;
    
    if (Offset < 0 || Offset >= CharArray->Val->Array.Size)
        CharPtr = StrEmpty;
    else
        CharPtr = CharArray->Val->Array.Data + Param[0]->Val->Pointer.Offset;
}}}

picoc strings work like C strings - they're pointers to arrays of characters, terminated by a null character. Once you have the C char `*` you can use it just like a normal C string.

Note that in this case if the pointer was invalid I've chosen to return an empty string rather than stopping the program. You can choose whichever approach suits your application best.

Pointers to arrays of other data types work the same way.


== Passing pointers to structures and unions ==

If you're defining library functions which take structures as parameters you'll have to do a little more work. You need to pre-define the structure so the function prototype can refer to it.

In *library_XXX.c* you'll find a function called PlatformLibraryInit(). This is called before the library prototypes are defined. Here's some code which will define a complex number structure:

{{{
void PlatformLibraryInit()
{
    struct ParseState Parser;
    char *Identifier;
    struct ValueType *ParsedType;
    void *Tokens;
    const char *IntrinsicName = TableStrRegister("platform library");
    const char *StructDefinition = "struct complex { int i; int j; }";
    
    /* define an example structure */
    Tokens = LexAnalyse(IntrinsicName, StructDefinition, strlen(StructDefinition), NULL);
    LexInitParser(&Parser, Tokens, IntrinsicName, 1, TRUE);
    TypeParse(&Parser, &ParsedType, &Identifier);
    HeapFree(Tokens);
}
}}}

This code takes the structure definition in StructDefinition and runs the lexical analyser over it. This returns some lexical tokens. Then we initialise the parser and have it parse the type of the structure definition from the tokens we made. That's enough to define the structure in the system. Finally we free the tokens.

Now let's say we're going to define a function to display a complex number. Our prototype will look like:
{{{
    { ShowComplex,   "void ShowComplex(struct complex *)" },
}}}

And finally we can define the library function:

{{{
void ShowComplex(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)
{
    struct Value *ComplexVal = Param[0]->Val->Pointer.Segment;  /* dereferences the pointer - note that I'm cheating by not using the offset here */
    struct Value *RealOffset;
    struct Value *ComplexOffset;
    int RealPart;
    int ComplexPart;
    struct ValueType *StructComplexType;
    
    /* find the type */
    StructComplexType = TypeGetMatching(Parser, &UberType, TypeStruct, 0, TableStrRegister("complex"));
    
    /* get the real and complex members */
    TableGet(StructComplexType->Members, TableStrRegister("i"), &RealOffset);
    RealPart = *(int *)((void *)ComplexVal->Val + RealOffset->Val->Integer);
    
    TableGet(StructComplexType->Members, TableStrRegister("j"), &ComplexOffset);
    ComplexPart = *(int *)((void *)ComplexVal->Val + ComplexOffset->Val->Integer);
    
    /* print the result */
    PrintInt(RealPart, PlatformPutc);
    PlatformPutc(',');
    PrintInt(ComplexPart, PlatformPutc);
}
}}}

Note that I've cheated a little here to make the example simpler. I dereferenced the pointer without using the pointer offset as I should have. This means that pointer arithmetic won't work correctly on that pointer so you're probably best advised to do it the long way shown in the previous sections.

The next step is to find the definition of the struct. This looks up a table of data types to find the correct one.

Structures are represented in picoc as hash tables. We look up the hash table of members of "struct complex" to find the member "i". This gives us an offset into our value where the data for "i" is stored. Then we use that offset to calculate "i"s address inside the parameter and dereference that pointer to (finally) get "i"s value.

Then we do the same thing for "j" and print out the result.

Unions work exactly the same way as structures. Define the prototype as "union" rather than "struct" and you're away.