#summary Adding native C library functions to picoc
#labels User-Library-Creation

= Introduction =

picoc allows you to define your own library functions. These functions are written in C using your system's native C compiler. Since the native C compiler can access the hardware this means you can add functions which give picoc control of your hardware.


= How libraries work =

Your picoc distribution will contain a two files which are used to define library functions for your system. If your system is called "foobar" you'll be using:
  * *library_foobar.c* - this is where the foobar-specific library functions go
  * *clibrary.c* - this is where standard C library functions like printf() are defined

We'll start by defining a simple function in *library_foobar.c*. We need to do two things:
  * add the function prototype to our list of picoc library functions
  * define the native C implementation of the function

== The prototype list ==

Each of the *library_XXX.c* files defines a list of picoc prototypes for each of the functions it defines. For example:

{{{
struct LibraryFunction PlatformLibrary[] =
{
    { ShowComplex,  "void ShowComplex(struct complex *)" },
    { Cpeek,        "int peek(int, int)" },
    { Cpoke,        "void poke(int, int, int)" },
    { Crandom,      "int random(int)" },
    { NULL,         NULL }
};
}}}

The first column is the name of the C function. The second column is the function prototype. The "{ NULL, NULL }" line at the end is required.

== The native C function ==

The native C function is called with these parameters:

{{{
void MyCFunc(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs);
}}}

 * struct ParseState `*`Parser - this contains internal information about the progress of parsing. It's mostly used here so error messages from your function can report the line number where an error occurred.
 * struct Value `*`ReturnValue - this points to the place you can put your return value. This is pre-created as a value of the correct return type so all you have to do is store your result here.
 * struct Value `**`Param - this points to an array of parameters. These are all pre-checked as being the correct type.
 * int NumArgs - this is the number of parameters. Normally this will already have been checked and will be exactly what you've defined in your function prototype. It is however possible to define functions with variable numbers of arguments using a stdarg-like "..." method and this is where you find out how many parameters were passed in if you're doing that.

Here's an example function definition:
{{{
void Crandom(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)
{
    ReturnValue->Val->Integer = random() % Param[0]->Val->Integer;
}
}}}

This function calls "random()" from the C standard library. It accesses an integer parameter and returns an integer value. Take a look at the definition of "union AnyValue" in *picoc.h* to see the other argument types.